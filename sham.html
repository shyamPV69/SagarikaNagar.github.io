<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA - Sagarika Nagar Business Cases</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Inter:wght@400;500;600;700&family=Playfair+Display:wght@700;800&display=swap" rel="stylesheet">
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      
      /* Navigation Header */
      nav {
        position: fixed;
        top: 0;
        width: 100%;
        background: rgba(255, 255, 255, 0.97);
        backdrop-filter: blur(10px);
        z-index: 100;
        padding: 1rem 2rem;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      
      nav ul {
        list-style: none;
        display: flex;
        justify-content: center;
        gap: 2rem;
        max-width: 1000px;
        margin: 0 auto;
      }
      
      nav a {
        font-weight: 500;
        color: #333;
        text-decoration: none;
        transition: color 0.3s ease;
        font-size: 1rem;
        font-family: 'Poppins', sans-serif;
      }
      
      nav a:hover {
        color: #667eea;
      }
      
      body {
        padding-top: 80px;
      }
      body { 
        font-family: 'Inter', 'Segoe UI', Arial, sans-serif; 
        background: linear-gradient(135deg, #69d6fa 0%, #0849ed 100%);
        color: #333; 
        padding: 2rem;
        line-height: 1.7;
        font-weight: 400;
      }
      .wrap { 
        max-width: 1000px; 
        margin: 0 auto; 
        background: #fff; 
        padding: 2.5rem; 
        border-radius: 12px; 
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      }
      
      h1 { 
        color: #667eea;
        font-size: 2.5rem; 
        margin-bottom: 0.5rem;
        text-align: center;
        font-weight: 800;
        font-family: 'Playfair Display', serif;
        letter-spacing: -0.5px;
      }
      
      h2 {
        color: #2c5aa0;
        font-size: 1.8rem;
        margin-top: 2.5rem;
        margin-bottom: 1rem;
        border-bottom: 3px solid #2c5aa0;
        padding-bottom: 0.5rem;
        font-family: 'Poppins', sans-serif;
        font-weight: 700;
        letter-spacing: -0.3px;
      }
      
      h3 {
        color: #1e40af;
        font-size: 1.4rem;
        margin-top: 1.8rem;
        margin-bottom: 0.8rem;
        font-weight: 700;
        font-family: 'Poppins', sans-serif;
        letter-spacing: -0.2px;
      }
      
      h4 {
        color: #555;
        font-size: 1.1rem;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        font-weight: 700;
        font-family: 'Poppins', sans-serif;
      }
      
      .intro-section {
        background: #f0f4ff;
        padding: 1.5rem;
        border-left: 5px solid #667eea;
        margin-bottom: 2rem;
        border-radius: 8px;
      }
      
      .zones-list {
        background: #f8f9ff;
        padding: 2rem;
        border-radius: 8px;
        margin-bottom: 2rem;
      }
      
      .zones-list ol {
        margin-left: 2rem;
      }
      
      .zones-list li {
        margin-bottom: 0.8rem;
        font-size: 1.05rem;
      }
      
      .business-case {
        background: #fafbff;
        padding: 2rem;
        margin-bottom: 2rem;
        border-radius: 8px;
        border-left: 5px solid #1e40af;
        box-shadow: 0 4px 15px rgba(0,0,0,0.05);
      }
      
      .case-number {
        background: #667eea;
        color: white;
        display: inline-block;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        font-weight: bold;
        margin-bottom: 1rem;
        font-size: 1.1rem;
      }
      
      .case-field {
        margin-bottom: 1.2rem;
      }
      
      .case-field-label {
        font-weight: 700;
        color: #1e40af;
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.8px;
        font-family: 'Poppins', sans-serif;
        font-size: 0.95rem;
      }
      
      .case-field-content {
        margin-top: 0.5rem;
        color: #444;
        font-size: 1.05rem;
        padding-left: 1rem;
        border-left: 3px solid #1e40af;
      }
      
      .bullet-list {
        list-style: none;
        margin-left: 1.5rem;
        margin-top: 0.5rem;
      }
      
      .bullet-list li {
        margin-bottom: 0.6rem;
        position: relative;
        padding-left: 1.5rem;
      }
      
      .bullet-list li:before {
        content: "*";
        position: absolute;
        left: 0;
        color: #1e40af;
        font-weight: bold;
      }
      
      .conclusion {
        background: linear-gradient(135deg, #71cef4 0%, #034db5 100%);
        color: white;
        padding: 2rem;
        border-radius: 8px;
        margin-top: 3rem;
        text-align: center;
      }
      
      .conclusion h2 {
        color: white;
        border-bottom: 2px solid white;
      }
      
      .conclusion p {
        font-size: 1.1rem;
        margin-top: 1rem;
        line-height: 1.8;
      }
      
      .meta { 
        color: #666; 
        margin-bottom: 1rem;
        text-align: center;
        font-style: italic;
      }
      
      .content { 
        margin-top: 1rem; 
        line-height: 1.8;
      }
      
      .divider {
        height: 2px;
        background: linear-gradient(to right, #92d4ee, transparent);
        margin: 2rem 0;
      }
      
      strong {
        color: #1e40af;
      }
      
      .link-placeholder {
        margin-top: 2.5rem;
        margin-bottom: 1rem;
        padding: 2rem;
        border: 2px dashed #1e40af;
        border-radius: 8px;
        background: #eff6ff;
        min-height: 100px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1rem;
        font-weight: 500;
      }
      
      .link-placeholder a {
        color: rgb(241, 244, 246);
        background: #1e40af;
        text-decoration: none;
        font-weight: 600;
        padding: 0.8rem 1.5rem;
        border-radius: 6px;
        transition: all 0.3s ease;
        display: inline-block;
        border: none;
      }
      
      .link-placeholder a:hover {
        background: #6890f7;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(2, 13, 48, 0.3);
      }
    </style>
</head>
<body>
    <!-- Navigation Header -->
    <nav>
      <ul>
        <li><a href="DAA website 2 1.html">Home</a></li>
        <li><a href="DAA website 2 1.html#about">About Me</a></li>
        <li><a href="DAA website 2 1.html#project">Project</a></li>
        <li><a href="DAA website 2 1.html#Map">Project Map</a></li>
      </ul>
    </nav>
    
    <div class="wrap">
      <h1>üèôÔ∏è Sagarika Nagar - DAA Business Cases</h1>
      <p class="meta">Design and Analysis of Algorithms Applied to Smart City Planning</p>
      <div class="divider"></div>
      
      <!-- SECTION A: SELECTED CITY ZONES -->
      <section>
        <h2>SECTION A ‚Äì SELECTED CITY ZONES OF SAGARIKA NAGAR</h2>
        
        <div style="margin: 2rem 0;">
          <h3>Residential Zone</h3>
          <p style="margin: 0.8rem 0;">Most people live here, so we must manage daily needs like water, electricity, buses, safety, and parking.</p>
          <p style="margin: 0.8rem 0;">Good planning here improves the quality of life for maximum citizens.</p>
        </div>
        
        <div style="margin: 2rem 0;">
          <h3>Commercial (Central City / Market Area)</h3>
          <p style="margin: 0.8rem 0;">This area has shops, malls, banks, and offices, so there is heavy foot traffic and vehicle traffic.</p>
          <p style="margin: 0.8rem 0;">Smart systems here can reduce crowding, improve business, and make shopping safer and faster.</p>
        </div>
        
        <div style="margin: 2rem 0;">
          <h3>IT Park &amp; Education Hub</h3>
          <p style="margin: 0.8rem 0;">Has colleges, coaching centres, and software companies with many students and employees moving in and out.</p>
          <p style="margin: 0.8rem 0;">Needs efficient transport, fast internet-based services, and strong safety/emergency planning.</p>
        </div>
        
        <div style="margin: 2rem 0;">
          <h3>Industrial &amp; Logistics Zone</h3>
          <p style="margin: 0.8rem 0;">Factories, warehouses, and transport godowns are located here; many trucks and goods move daily.</p>
          <p style="margin: 0.8rem 0;">Better scheduling and routing can reduce delays and save fuel and money.</p>
        </div>
        
        <div style="margin: 2rem 0;">
          <h3>Airport &amp; Transport Hub (Bus/Railway)</h3>
          <p style="margin: 0.8rem 0;">Key entry and exit point of Sagarika Nagar; tourists, business travellers, and cargo pass through here.</p>
          <p style="margin: 0.8rem 0;">Needs smart parking, quick security checks, and fast connection to other city zones.</p>
        </div>
      </section>


      
      <!-- SECTION B: BUSINESS CASES 1-10 -->
      <section>
        <h2>SECTION B ‚Äì BUSINESS CASES 1‚Äì10</h2>
      
      <!-- Business Case 1 -->
      <div class="business-case">
        <h3>Business Case 1: Smart Bus Route Optimisation</h3>
        
        <div class="case-field">
          <div class="case-field-label">Title:</div>
          <div class="case-field-content">Fast &amp; Cheap Bus Routes between Residential, IT Park and Commercial Area</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Zones Involved:</div>
          <div class="case-field-content">Residential Zone ‚Üî IT Park &amp; Education Hub ‚Üî Commercial (Central City)</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Real-world Problem:</div>
          <div class="case-field-content">Many people travel daily from homes to IT Park and Commercial Area. Current bus routes are fixed and not always shortest. This increases travel time and fuel cost.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Goal / Objective:</div>
          <div class="case-field-content">Find shortest-time or shortest-distance bus routes between major bus stops in these zones.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Chosen Data Structure / Algorithm:</div>
          <div class="case-field-content"><strong>Dijkstra's Shortest Path Algorithm</strong> (using a graph)</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Why This is Suitable:</div>
          <ul class="bullet-list">
            <li>The city road network can be modelled as a graph (junctions = nodes, roads = edges with weights like distance or time).</li>
            <li>Dijkstra finds the minimum cost path from one source stop to all other stops, which matches our need for shortest bus routes.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">High-level Working / Steps:</div>
          <ul class="bullet-list">
            <li>Represent all bus stops as nodes and roads between them with travel time as edge weight.</li>
            <li>Choose the starting stop (e.g., a big residential bus stand) as the source.</li>
            <li>Use Dijkstra to update the shortest known distance to each neighbouring stop.</li>
            <li>Keep picking the next stop with minimum current distance (using a min-heap / priority queue).</li>
            <li>Continue until all stops are processed.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Time &amp; Space Efficiency:</div>
          <ul class="bullet-list">
            <li>Time Complexity: O((V + E) log V) using a min-heap (V = stops, E = roads).</li>
            <li>Space Complexity: O(V + E) for storing the graph and distance arrays.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Expected Output / Real-world Benefit:</div>
          <ul class="bullet-list">
            <li>Buses follow faster routes, passengers reach earlier, and fuel usage is reduced.</li>
            <li>Easy to re-run if traffic conditions or roadworks change.</li>
          </ul>
        </div>
        
        <div class="link-placeholder"><a href="dijkstra.cpp" id="link-dijkstra">View Dijkstra code</a></div>
      </div>
      
      <!-- Business Case 2 -->
      <div class="business-case">
        <h3>Business Case 2: Emergency Ambulance Dispatch System</h3>
        
        <div class="case-field">
          <div class="case-field-label">Title:</div>
          <div class="case-field-content">Nearest Ambulance Finder for Road Accidents</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Zones Involved:</div>
          <div class="case-field-content">Residential Zone, Commercial Area, Airport &amp; Transport Hub, Industrial Zone</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Real-world Problem:</div>
          <div class="case-field-content">When an accident happens, control room staff must quickly decide which ambulance to send. If they choose badly, response time increases.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Goal / Objective:</div>
          <div class="case-field-content">Always send the nearest available ambulance to the emergency location.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Chosen Data Structure / Algorithm:</div>
          <div class="case-field-content"><strong>Heap / Priority Queue</strong></div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Why This is Suitable:</div>
          <ul class="bullet-list">
            <li>A min-heap priority queue can store ambulances ordered by their current distance or time to reach the accident location.</li>
            <li>Getting the nearest ambulance becomes simply "take the top element of the heap".</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">High-level Working / Steps:</div>
          <ul class="bullet-list">
            <li>When an emergency call comes, calculate estimated distance/time from each available ambulance to the incident location.</li>
            <li>Insert (distance, ambulance_id) pairs into a min-heap.</li>
            <li>Extract the minimum element from the heap ‚Üí gives the best ambulance to send.</li>
            <li>After dispatch, update that ambulance's status and position.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Time &amp; Space Efficiency:</div>
          <ul class="bullet-list">
            <li>Insertion into heap: O(log n) per ambulance</li>
            <li>Get nearest ambulance (extract-min): O(log n)</li>
            <li>Space Complexity: O(n) for n ambulances.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Expected Output / Real-world Benefit:</div>
          <ul class="bullet-list">
            <li>Lower response time, more lives saved, better use of limited ambulances.</li>
          </ul>
        </div>
        
        <div class="link-placeholder"><a href="minheap.cpp" id="link-minheap">View Min-Heap code</a></div>
      </div>
      
      <!-- Business Case 3 -->
      <div class="business-case">
        <h3>Business Case 3: Fast Resident ID &amp; Smart Card Verification</h3>
        
        <div class="case-field">
          <div class="case-field-label">Title:</div>
          <div class="case-field-content">Instant Smart Card Check at Metro / Bus Gates</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Zones Involved:</div>
          <div class="case-field-content">Residential Zone, Commercial Area, IT Park &amp; Education Hub</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Real-world Problem:</div>
          <div class="case-field-content">At metro gates or smart bus stops, thousands of people tap their smart cards daily. The system must quickly check if the card is valid and has balance.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Goal / Objective:</div>
          <div class="case-field-content">Verify user identity and card status in constant time to avoid queues.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Chosen Data Structure / Algorithm:</div>
          <div class="case-field-content"><strong>Hash Table / Hashing</strong></div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Why This is Suitable:</div>
          <ul class="bullet-list">
            <li>A hash table allows almost O(1) average time lookup using a unique card number as key.</li>
            <li>Perfect for large-scale systems where many lookups happen per second.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">High-level Working / Steps:</div>
          <ul class="bullet-list">
            <li>Store each smart card record as an entry in a hash table: key = card number, value = user details + balance.</li>
            <li>When a card is tapped, compute its hash and directly access the record.</li>
            <li>Check if card is active and has enough balance; then allow or deny entry.</li>
            <li>Update balance after successful entry.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Time &amp; Space Efficiency:</div>
          <ul class="bullet-list">
            <li>Lookup Time Complexity (average): O(1)</li>
            <li>Insertion Time Complexity (average): O(1)</li>
            <li>Space Complexity: O(n) for n smart cards.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Expected Output / Real-world Benefit:</div>
          <ul class="bullet-list">
            <li>Very small waiting time at gates, smooth passenger flow, and quick fraud detection.</li>
          </ul>
        </div>
        
        <div class="link-placeholder"><a href="hashtable.cpp" id="link-hashtable">View Hash Table code</a></div>
      </div>
      
      <!-- Business Case 4 -->
      <div class="business-case">
        <h3>Business Case 4: Smart Power Usage Monitoring in Apartments</h3>
        
        <div class="case-field">
          <div class="case-field-label">Title:</div>
          <div class="case-field-content">Dynamic Electricity Load Monitoring for Residential Towers</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Zones Involved:</div>
          <div class="case-field-content">Residential Zone, Industrial Zone (can also monitor heavy usage there)</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Real-world Problem:</div>
          <div class="case-field-content">The power department must monitor how much electricity each apartment block consumes in different hours. They need fast answers for "total usage in this time range" and "update when usage changes".</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Goal / Objective:</div>
          <div class="case-field-content">Efficiently perform range sum queries and point updates of electricity usage.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Chosen Data Structure / Algorithm:</div>
          <div class="case-field-content"><strong>Segment Tree</strong></div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Why This is Suitable:</div>
          <ul class="bullet-list">
            <li>Segment trees are ideal for range queries (like total power between 2 PM‚Äì6 PM) with frequent updates.</li>
            <li>They provide both fast query and update operations.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">High-level Working / Steps:</div>
          <ul class="bullet-list">
            <li>Represent each time slot (e.g., hourly usage) as an array element.</li>
            <li>Build a segment tree where each node stores the sum of a range of time slots.</li>
            <li>For query: to get total usage between time L and R, traverse the segment tree and combine relevant segments.</li>
            <li>For update: when usage in a particular time slot changes, update that leaf and fix sums up the tree.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Time &amp; Space Efficiency:</div>
          <ul class="bullet-list">
            <li>Build Time: O(n)</li>
            <li>Query Time: O(log n)</li>
            <li>Update Time: O(log n)</li>
            <li>Space Complexity: O(n) (typically about 4n memory).</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Expected Output / Real-world Benefit:</div>
          <ul class="bullet-list">
            <li>Quick detection of peak load times, better planning of power supply, and early alert for abnormal usage or theft.</li>
          </ul>
        </div>
        
        <div class="link-placeholder"><a href="segment_tree.cpp" id="link-segtree">View Segment Tree code</a></div>
      </div>
      
      <!-- Business Case 5 -->
      <div class="business-case">
        <h3>Business Case 5: Water Pipeline Leakage &amp; Network Control</h3>
        
        <div class="case-field">
          <div class="case-field-label">Title:</div>
          <div class="case-field-content">Find Connected Affected Areas in Water Pipeline Network</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Zones Involved:</div>
          <div class="case-field-content">Residential Zone, Industrial Zone, Commercial Area</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Real-world Problem:</div>
          <div class="case-field-content">When a water main pipeline leaks or breaks, some sectors lose water. The maintenance team must know which sectors are connected to that broken pipe to close valves and reroute supply.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Goal / Objective:</div>
          <div class="case-field-content">Quickly find and group all connected parts of the pipeline network.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Chosen Data Structure / Algorithm:</div>
          <div class="case-field-content"><strong>Union-Find / Disjoint Set</strong></div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Why This is Suitable:</div>
          <ul class="bullet-list">
            <li>Union-Find efficiently keeps track of which nodes (pipeline segments or junctions) belong to the same connected component.</li>
            <li>When a pipe breaks, you can determine which regions are disconnected using find operations.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">High-level Working / Steps:</div>
          <ul class="bullet-list">
            <li>Consider each junction as a node; connect them (union) when a pipe exists between them.</li>
            <li>Initially build sets for all connected segments using union operations.</li>
            <li>When a leak or break is reported, we conceptually "remove" or mark that edge and check which junctions are still in the same set.</li>
            <li>Components that become separate show which areas lose water.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Time &amp; Space Efficiency:</div>
          <ul class="bullet-list">
            <li>Union / Find (amortized): ~O(1) (technically O(Œ±(n)), inverse Ackermann, almost constant).</li>
            <li>Space Complexity: O(n) for n junctions.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Expected Output / Real-world Benefit:</div>
          <ul class="bullet-list">
            <li>Faster isolation of problem areas and better control of water pressure.</li>
            <li>Less wastage of water and reduced disruption for citizens.</li>
          </ul>
        </div>
        
        <div class="link-placeholder"><a href="dsu.cpp" id="link-dsu">View DSU code</a></div>
      </div>
      
      <!-- Business Case 6 -->
      <div class="business-case">
        <h3>Business Case 6: Auto-complete for City Services &amp; Shops</h3>
        
        <div class="case-field">
          <div class="case-field-label">Title:</div>
          <div class="case-field-content">Smart Search for Shop/Place Names in Sagarika Nagar App</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Zones Involved:</div>
          <div class="case-field-content">Commercial Area, Residential Zone, IT Park &amp; Education Hub</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Real-world Problem:</div>
          <div class="case-field-content">Citizens use a city app to search "medical", "market street", "Sagarika Tech Park", etc. With thousands of names, normal search becomes slow, especially on mobile internet.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Goal / Objective:</div>
          <div class="case-field-content">Provide fast auto-complete suggestions as the user types.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Chosen Data Structure / Algorithm:</div>
          <div class="case-field-content"><strong>Trie (Prefix Tree)</strong></div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Why This is Suitable:</div>
          <ul class="bullet-list">
            <li>Trie stores strings character by character in a tree form, which is very efficient for prefix-based search.</li>
            <li>Auto-complete is basically: "Show all strings starting with this prefix".</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">High-level Working / Steps:</div>
          <ul class="bullet-list">
            <li>Insert all shop, street, and landmark names into a trie, letter by letter.</li>
            <li>When the user types a prefix (e.g., "Sa"), walk down the trie following those characters.</li>
            <li>From that node, collect all possible continuations as suggestions ("Sagarika Mall", "Sagarika Tech Park"‚Ä¶).</li>
            <li>Show top-k results on screen.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Time &amp; Space Efficiency:</div>
          <ul class="bullet-list">
            <li>Insert a word of length L: O(L)</li>
            <li>Search / Auto-complete for prefix length P: O(P + output_size)</li>
            <li>Space Complexity: O(total characters of all names).</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Expected Output / Real-world Benefit:</div>
          <ul class="bullet-list">
            <li>Fast and user-friendly search experience, helping citizens quickly find services and locations.</li>
          </ul>
        </div>
        
        <div class="link-placeholder"><a href="trie.cpp" id="link-trie">View Trie code</a></div>
      </div>
      
      <!-- Business Case 7 -->
      <div class="business-case">
        <h3>Business Case 7: Fire Emergency Evacuation in IT Park</h3>
        
        <div class="case-field">
          <div class="case-field-label">Title:</div>
          <div class="case-field-content">Shortest Escape Path in IT Park Buildings</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Zones Involved:</div>
          <div class="case-field-content">IT Park &amp; Education Hub</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Real-world Problem:</div>
          <div class="case-field-content">In case of fire, people need to know the shortest path to the nearest safe exit in a building or campus.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Goal / Objective:</div>
          <div class="case-field-content">Compute shortest number of steps / doors between any room and nearest exit.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Chosen Data Structure / Algorithm:</div>
          <div class="case-field-content"><strong>BFS (Breadth-First Search) on an Unweighted Graph</strong></div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Why This is Suitable:</div>
          <ul class="bullet-list">
            <li>If we assume each corridor/door has equal cost, the building can be treated as an unweighted graph.</li>
            <li>BFS finds the shortest path in terms of number of edges in such graphs.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">High-level Working / Steps:</div>
          <ul class="bullet-list">
            <li>Represent each room/area as a node and corridors as edges.</li>
            <li>Mark the exits as target nodes.</li>
            <li>For each room, or from exits backward, run BFS to compute the minimum distance (in steps) to reach an exit.</li>
            <li>Store paths and show them on dynamic building maps and emergency display boards.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Time &amp; Space Efficiency:</div>
          <ul class="bullet-list">
            <li>Time Complexity: O(V + E) (V = rooms, E = connections).</li>
            <li>Space Complexity: O(V) for queues and visited arrays.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Expected Output / Real-world Benefit:</div>
          <ul class="bullet-list">
            <li>Clear, pre-computed escape routes, faster evacuation, fewer casualties in emergencies.</li>
          </ul>
        </div>
        
        <div class="link-placeholder"><a href="bfs.cpp" id="link-bfs">View BFS code</a></div>
      </div>
      
      <!-- Business Case 8 -->
      <div class="business-case">
        <h3>Business Case 8: Optimised Truck Scheduling in Industrial Zone</h3>
        
        <div class="case-field">
          <div class="case-field-label">Title:</div>
          <div class="case-field-content">Sort Incoming and Outgoing Truck Schedules</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Zones Involved:</div>
          <div class="case-field-content">Industrial &amp; Logistics Zone, Airport &amp; Transport Hub</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Real-world Problem:</div>
          <div class="case-field-content">Many trucks bring raw materials and take finished goods daily. If arrival and departure times are unsorted, docks and loading bays become congested.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Goal / Objective:</div>
          <div class="case-field-content">Sort truck schedules by arrival time, departure time, or load priority.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Chosen Data Structure / Algorithm:</div>
          <div class="case-field-content"><strong>Merge Sort</strong> (a stable sorting algorithm)</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Why This is Suitable:</div>
          <ul class="bullet-list">
            <li>Merge sort is efficient and gives O(n log n) time in worst case, unlike quick sort which can become O(n¬≤) in bad cases.</li>
            <li>It is stable, so trucks with same arrival time maintain their original priority order.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">High-level Working / Steps:</div>
          <ul class="bullet-list">
            <li>Take the list of trucks with fields like (arrival_time, priority, dock_number).</li>
            <li>Recursively divide the list into halves until single elements remain.</li>
            <li>Merge the halves back together in sorted order using the chosen key (e.g., arrival_time).</li>
            <li>Use the sorted list to create a clear dock schedule.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Time &amp; Space Efficiency:</div>
          <ul class="bullet-list">
            <li>Time Complexity: O(n log n)</li>
            <li>Space Complexity: O(n) extra space for merging.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Expected Output / Real-world Benefit:</div>
          <ul class="bullet-list">
            <li>Reduced waiting time for trucks, less congestion, better use of docks and manpower.</li>
          </ul>
        </div>
        
        <div class="link-placeholder"><a href="merge_sort.cpp" id="link-mergesort">View Merge Sort code</a></div>
      </div>
      
      <!-- Business Case 9 -->
      <div class="business-case">
        <h3>Business Case 9: Smart Filtering of Citizen Complaints</h3>
        
        <div class="case-field">
          <div class="case-field-label">Title:</div>
          <div class="case-field-content">Detect Offensive or Urgent Keywords in Complaint Messages</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Zones Involved:</div>
          <div class="case-field-content">Entire City (Residential, Commercial, IT Park, etc.)</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Real-world Problem:</div>
          <div class="case-field-content">The city's grievance portal receives thousands of text complaints daily. Staff must quickly detect messages with urgent words like "fire", "accident", "collapse" or filter out abusive language.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Goal / Objective:</div>
          <div class="case-field-content">Fast pattern matching of important keywords inside long text complaints.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Chosen Data Structure / Algorithm:</div>
          <div class="case-field-content"><strong>Knuth‚ÄìMorris‚ÄìPratt (KMP) String Matching</strong></div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Why This is Suitable:</div>
          <ul class="bullet-list">
            <li>KMP avoids re-checking characters unnecessarily and gives linear time matching of a pattern in a text.</li>
            <li>Useful when we repeatedly search many complaints for the same set of key patterns.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">High-level Working / Steps:</div>
          <ul class="bullet-list">
            <li>Preprocess the keyword/pattern (e.g., "fire in building") to create KMP's prefix table (LPS array).</li>
            <li>For each complaint, run KMP to check if the pattern appears in the text.</li>
            <li>If found, tag the complaint as high priority or contains abusive language.</li>
            <li>Route urgent complaints to emergency teams and others to normal departments.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Time &amp; Space Efficiency:</div>
          <ul class="bullet-list">
            <li>Pattern Preprocessing: O(m) where m = length of pattern.</li>
            <li>Text Search: O(n) where n = length of complaint text.</li>
            <li>Space Complexity: O(m) for prefix table.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Expected Output / Real-world Benefit:</div>
          <ul class="bullet-list">
            <li>Faster identification of critical issues, quicker response by authorities, and automatic filtering of abusive content.</li>
          </ul>
        </div>
        
        <div class="link-placeholder"><a href="kmp.cpp" id="link-kmp">View KMP code</a></div>
      </div>
      
      <!-- Business Case 10 -->
      <div class="business-case">
        <h3>Business Case 10: Smart Parking Management at Airport &amp; Malls</h3>
        
        <div class="case-field">
          <div class="case-field-label">Title:</div>
          <div class="case-field-content">Balanced Parking Slot Allocation near Airport and Central Malls</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Zones Involved:</div>
          <div class="case-field-content">Airport &amp; Transport Hub, Commercial Area</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Real-world Problem:</div>
          <div class="case-field-content">Parking lots near the airport and big malls often get full in some sections while other sections still have space. Searching randomly wastes time and fuel.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Goal / Objective:</div>
          <div class="case-field-content">Quickly find the nearest available parking slot and keep parking distribution balanced.</div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Chosen Data Structure / Algorithm:</div>
          <div class="case-field-content"><strong>AVL Tree (Self-Balancing Binary Search Tree)</strong></div>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Why This is Suitable:</div>
          <ul class="bullet-list">
            <li>Each parking slot (or block) can be stored in an AVL tree ordered by some key: distance from entrance, slot number, or level.</li>
            <li>AVL tree keeps itself height-balanced, so search, insert, and delete operations are all O(log n).</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">High-level Working / Steps:</div>
          <ul class="bullet-list">
            <li>Represent each free slot as a node in an AVL tree, key based on distance or preference.</li>
            <li>When a car arrives, search the tree for the best suitable slot (e.g., smallest distance).</li>
            <li>On allocation, remove that slot from the tree.</li>
            <li>When a car leaves, insert that slot back into the tree.</li>
            <li>The tree rotations keep it balanced automatically.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Time &amp; Space Efficiency:</div>
          <ul class="bullet-list">
            <li>Search / Insert / Delete: O(log n) each.</li>
            <li>Space Complexity: O(n) for n parking slots.</li>
          </ul>
        </div>
        
        <div class="case-field">
          <div class="case-field-label">Expected Output / Real-world Benefit:</div>
          <ul class="bullet-list">
            <li>Drivers get parking quickly, reduced circling and congestion, better user experience and improved revenue tracking.</li>
          </ul>
        </div>
        
        <div class="link-placeholder"><a href="avl.cpp" id="link-avl">View AVL code</a></div>
      </div>
      
      <!-- Data Structures Examples -->
      <section>
        <h2>DATA STRUCTURES ‚Äì EXAMPLES AND CODE</h2>
        <div class="content">
          
          <h3> Arrays</h3>
          <h4>Algorithm</h4>
          <p>Arrays are used here to store a collection of fixed-size, sequential elements. The <strong>cities</strong> array holds location names (strings), and the <strong>distances</strong> array holds corresponding numeric values (floats) for quick, direct access via index.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Access: $O(1)$</li>
            <li>Search (Unsorted): $O(n)$</li>
            <li>Space Complexity: $O(n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>The code uses two parallel arrays to store city names and their distances from a starting point ("Sagarika Nagar"). A simple <code>for</code> loop iterates through the fixed-size arrays to print each city and its associated distance, illustrating $O(1)$ indexed retrieval.</p>
          
          <div class="link-placeholder"><a href="arrays.cpp" id="link-arrays">View Arrays code</a></div>

          <div class="divider"></div>

          <h3> Structures</h3>
          <h4>Algorithm</h4>
          <p>Structures (structs) are user-defined data types that logically group related data items of different types under a single name. This allows for creating complex data records, like a <strong>City</strong> object containing a name, distance, and zone.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Access to members: $O(1)$</li>
            <li>Space Complexity: $O(1)$ per struct instance</li>
          </ul>
          <h4>Explanation</h4>
          <p>A <strong>City</strong> structure is defined to hold three related pieces of information: <strong>name</strong> (string), <strong>distance</strong> (float), and <strong>zone</strong> (string). The <code>main</code> function creates and initializes instances of this structure (<code>city1</code>, <code>city2</code>) and then accesses and prints the grouped data using the dot (<code>.</code>) operator.</p>

          <div class="link-placeholder"><a href="structures.cpp" id="link-structures">View Structures code</a></div>

          <div class="divider"></div>

          <h3> Linked List</h3>
          <h4>Algorithm</h4>
          <p>A Linked List is a dynamic, linear data structure where elements are stored in <strong>Nodes</strong>. Each Node contains data (location) and a reference (<strong>next</strong>) to the next Node in the sequence. It is efficient for sequential travel path storage and for insertions/deletions.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Insertion/Deletion (at end, in this code): $O(n)$</li>
            <li>Insertion/Deletion (at head): $O(1)$</li>
            <li>Search: $O(n)$</li>
            <li>Space Complexity: $O(n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>The code implements a basic singly linked list to represent a travel path. Each Node holds a location name and a pointer to the next node. The <code>addLocation</code> function traverses to the end of the list ($O(n)$) to append a new city, and <code>displayPath</code> iterates through the nodes to print the route.</p>
          
          <div class="link-placeholder"><a href="linked_list.cpp" id="link-linkedlist">View Linked List code</a></div>

          <div class="divider"></div>

          <h3> Stack</h3>
          <h4>Algorithm</h4>
          <p>A Stack is a LIFO (Last-In, First-Out) data structure. In a map context, it's ideal for keeping track of the path taken to facilitate backtracking, like when a mapping algorithm needs to "undo" the last move.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Push/Pop: $O(1)$</li>
            <li>Access: $O(n)$</li>
            <li>Space Complexity: $O(n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>The <code>std::stack</code> container is used to store <strong>visitedLocations</strong>. Cities are added using <code>push()</code>, and they are retrieved and removed in the reverse order of insertion using <code>top()</code> and <code>pop()</code>. This simulates a <strong>backtracking</strong> process, where the program returns from the last visited location first.</p>
         
          <div class="link-placeholder"><a href="stack.cpp" id="link-stack">View Stack code</a></div>

          <div class="divider"></div>

          <h3> Queue</h3>
          <h4>Algorithm</h4>
          <p>A Queue is a FIFO (First-In, First-Out) data structure. It's a fundamental component of the Breadth-First Search (BFS) algorithm, where locations at the current depth level are visited before moving to the next level.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Enqueue (Push)/Dequeue (Pop): $O(1)$</li>
            <li>Access: $O(n)$</li>
            <li>Space Complexity: $O(n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>The <code>std::queue</code> container stores locations to be visited in a FIFO order. Cities are added with <code>push()</code> and processed with <code>front()</code> followed by <code>pop()</code>. This structure represents the order in which locations are explored during a <strong>Breadth-First Search (BFS)</strong> pathfinding approach.</p>
       
          <div class="link-placeholder"><a href="queue.cpp" id="link-queue">View Queue code</a></div>
        </div>
      </section>

      <!-- Advanced Data Structures (6‚Äì10) -->
      <section>
        <h2>ADVANCED DATA STRUCTURES ‚Äì EXAMPLES AND LINKS</h2>
        <div class="content">
          
          <h3> Binary Tree</h3>
          <h4>Algorithm</h4>
          <p>A Binary Tree is a hierarchical data structure where each node has at most two children, referred to as the left child and the right child. It is used here to model hierarchical relationships, such as dividing a map into progressively smaller regions.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Insertion/Search (Unbalanced): $O(n)$</li>
            <li>Traversal: $O(n)$</li>
            <li>Space Complexity: $O(n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>This code defines a <strong>TreeNode</strong> structure to represent map regions. It manually constructs a small binary tree, with "Sagarika Nagar" as the root. The <code>preorderTraversal</code> function recursively visits the nodes in the order: root ‚Üí left subtree ‚Üí right subtree.</p>
          <div class="link-placeholder"><a href="binary_tree.cpp" id="link-binarytree">View Binary Tree code</a></div>

          <div class="divider"></div>

          <h3> Binary Search Tree</h3>
          <h4>Algorithm</h4>
          <p>A Binary Search Tree (BST) is a binary tree where the left child's key is always less than the parent's key, and the right child's key is always greater. This enables efficient searching and insertion.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Insertion/Search (Average): $O(\log n)$</li>
            <li>Insertion/Search (Worst Case ‚Äì Unbalanced): $O(n)$</li>
            <li>Inorder Traversal: $O(n)$</li>
            <li>Space Complexity: $O(n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>The <strong>BSTNode</strong> stores a city name and its distance as the key. The <code>insert</code> function maintains the BST property, and <strong>inorder</strong> traversal prints cities sorted by distance.</p>
          <div class="link-placeholder"><a href="bst.cpp" id="link-bst">View BST code</a></div>

          <div class="divider"></div>

          <h3> 2‚Äë3 Tree</h3>
          <h4>Algorithm</h4>
          <p>A 2‚Äë3 Tree is a self-balancing search tree where internal nodes have two or three children and one or two keys. All leaves are at the same level.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Insertion/Search: $O(\log n)$</li>
            <li>Space Complexity: $O(n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>A simplified, hardcoded structure shows <strong>TwoThreeNode</strong> keys and children. The <code>traverse23</code> function demonstrates an inorder‚Äëlike traversal.</p>
          <div class="link-placeholder"><a href="two_three_tree.cpp" id="link-23tree">View 2‚Äë3 Tree code</a></div>

          <div class="divider"></div>

          <h3> Red‚ÄëBlack Tree</h3>
          <h4>Algorithm</h4>
          <p>A Red‚ÄëBlack Tree is a self‚Äëbalancing BST that guarantees $O(\log n)$ search, insert, and delete by enforcing coloring and rotation properties.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Insertion/Search: $O(\log n)$</li>
            <li>Space Complexity: $O(n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>A simplified structure demonstrates inserts and a preorder <strong>display</strong> with node colors.</p>
          <div class="link-placeholder"><a href="red_black_tree.cpp" id="link-rbt">View Red‚ÄëBlack Tree code</a></div>

          <div class="divider"></div>

          <h3> Lookup Table (Hash Map)</h3>
          <h4>Algorithm</h4>
          <p>A direct lookup table using <code>std::unordered_map</code> for near $O(1)$ average lookups, insertions, and deletions.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Insertion/Search/Deletion (Average): $O(1)$</li>
            <li>Insertion/Search/Deletion (Worst Case ‚Äì Collision): $O(n)$</li>
            <li>Space Complexity: $O(n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>Stores predefined routes like "Sagarika Nagar to Kundapura" mapped to distances for fast retrieval.</p>
          <div class="link-placeholder"><a href="lookup_table.cpp" id="link-lookup">View Lookup Table code</a></div>
        </div>
      </section>

      <!-- More Data Structures (11‚Äì15) -->
      <section>
        <div class="content">
          
          <h3> Sparse Table</h3>
          <h4>Algorithm</h4>
          <p>A Sparse Table answers RMQ (Range Minimum Query) on a static array by preprocessing in $O(n \log n)$ and answering queries in $O(1)$.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Preprocessing: $O(n \log n)$</li>
            <li>Query: $O(1)$</li>
            <li>Space: $O(n \log n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>The structure stores minimums for ranges of length \(2^k\) and answers each query by combining two precomputed blocks.</p>
          <div class="link-placeholder"><a href="sparse_table.cpp" id="link-sparse">View Sparse Table code</a></div>

          <div class="divider"></div>

          <h3> Fenwick Tree (BIT)</h3>
          <h4>Algorithm</h4>
          <p>A Fenwick Tree maintains prefix sums with both updates and queries in $O(\log n)$.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Update: $O(\log n)$</li>
            <li>Prefix Sum Query: $O(\log n)$</li>
            <li>Space: $O(n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>Distances are aggregated in a tree-shaped array; updates propagate upward and queries accumulate downward.</p>
          <div class="link-placeholder"><a href="fenwick_tree.cpp" id="link-fenwick">View Fenwick Tree code</a></div>

          <div class="divider"></div>

          <h3> Skip List</h3>
          <h4>Algorithm</h4>
          <p>A probabilistic ordered structure with multiple levels that provides expected $O(\log n)$ search, insert, and delete.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Average operations: $O(\log n)$</li>
            <li>Worst case: $O(n)$</li>
            <li>Space: $O(n)$ (average)</li>
          </ul>
          <h4>Explanation</h4>
          <p>Higher levels act like express lanes to quickly narrow down positions for operations.</p>
          <div class="link-placeholder"><a href="skip_list.cpp" id="link-skiplist">View Skip List code</a></div>

          <div class="divider"></div>

          <h3> DFS (Depth-First Search)</h3>
          <h4>Algorithm</h4>
          <p>Traverses graphs deeply using a stack, visiting along branches before backtracking.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>$O(V + E)$</li>
            <li>Space: $O(V)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>An adjacency list represents city connections; the traversal prints visited nodes.</p>
          <div class="link-placeholder"><a href="dfs.cpp" id="link-dfs">View DFS code</a></div>

          <div class="divider"></div>

          <h3> Bubble Sort</h3>
          <h4>Algorithm</h4>
          <p>Repeatedly compares and swaps adjacent elements until the array is sorted.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Worst/Average: $O(n^2)$</li>
            <li>Best (already sorted): $O(n)$</li>
            <li>Space: $O(1)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>Sorts distances and keeps city names aligned, producing cities ordered by closest distance.</p>
          <div class="link-placeholder"><a href="bubble_sort.cpp" id="link-bubblesort">View Bubble Sort code</a></div>
        </div>
      </section>
<!-- Sorting & String Search (16‚Äì20) -->
      <section>
        <h2></h2>
        <div class="content">
          
          <h3> Selection Sort</h3>
          <h4>Algorithm</h4>
          <p>Selection Sort divides the array into sorted and unsorted parts, repeatedly selecting the minimum from the unsorted portion and placing it at the beginning.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Worst/Average/Best: $O(n^2)$</li>
            <li>Space: $O(1)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>Finds the smallest distance index in the remaining range and swaps it with the current position to build a sorted list of closest cities.</p>
          <div class="link-placeholder"><a href="selection_sort.cpp" id="link-selection">View Selection Sort code</a></div>

          <div class="divider"></div>

          <h3> Insertion Sort</h3>
          <h4>Algorithm</h4>
          <p>Insertion Sort builds the sorted array one element at a time by inserting the current element into its correct position among previously sorted elements.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Worst/Average: $O(n^2)$</li>
            <li>Best (already sorted): $O(n)$</li>
            <li>Space: $O(1)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>Shifts larger distances right and inserts the current city/distance pair into the correct position.</p>
          <div class="link-placeholder"><a href="insertion_sort.cpp" id="link-insertion">View Insertion Sort code</a></div>

          <div class="divider"></div>

          <h3> Quick Sort</h3>
          <h4>Algorithm</h4>
          <p>Quick Sort uses divide-and-conquer with a pivot to partition distances into less and greater groups, then recursively sorts subarrays.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Average: $O(n \log n)$</li>
            <li>Worst: $O(n^2)$</li>
            <li>Space: $O(\log n)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>Partitions around a pivot distance and keeps city names aligned, yielding efficient sorting by distance.</p>
          <div class="link-placeholder"><a href="quick_sort.cpp" id="link-quick">View Quick Sort code</a></div>

          <div class="divider"></div>

          <h3> Brute Force String Search</h3>
          <h4>Algorithm</h4>
          <p>Checks for a pattern at every possible starting position by comparing all characters, a simple baseline for matching.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>$O(n \cdot m)$</li>
            <li>Space: $O(1)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>Scans city names for exact matches of a substring and reports positions where matches occur.</p>
          <div class="link-placeholder"><a href="brute_force_search.cpp" id="link-bruteforce">View Brute Force Search code</a></div>

          <div class="divider"></div>

          <h3> Rabin‚ÄëKarp</h3>
          <h4>Algorithm</h4>
          <p>Uses rolling hash to quickly compare hash values of substrings with the pattern, verifying matches when hashes align.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Average: $O(n + m)$</li>
            <li>Worst (collisions): $O(n \cdot m)$</li>
            <li>Space: $O(1)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>Computes the pattern hash and slides a window across the text, updating the hash in constant time to find matches quickly.</p>
          <div class="link-placeholder"><a href="rabin_karp.cpp" id="link-rabinkarp">View Rabin‚ÄëKarp code</a></div>
        </div>
      </section>
       <!-- Sorting & String Search (21‚Äì22) -->
      <section>
        <h2></h2>
        <div class="content">
          
          <h3> Boyer‚ÄëMoore</h3>
          <h4>Algorithm</h4>
          <p>The Boyer‚ÄëMoore string search checks the pattern from right to left and uses heuristics to skip large sections of text.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Best: $O(n/m)$</li>
            <li>Worst: $O(n \cdot m)$</li>
            <li>Space: $O(|\Sigma|)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>Implements the Bad Character heuristic by precomputing last occurrence positions to determine efficient right shifts on mismatch.</p>
          <div class="link-placeholder"><a href="boyer_moore.cpp" id="link-bm">View Boyer‚ÄëMoore code</a></div>

          <div class="divider"></div>

          <h3> Heap Sort</h3>
          <h4>Algorithm</h4>
          <p>Heap Sort builds a max‚Äëheap of distances, repeatedly extracts the maximum, and heapifies the reduced array to produce sorted output.</p>
          <h4>Time Complexity</h4>
          <ul class="bullet-list">
            <li>Worst/Average/Best: $O(n \log n)$</li>
            <li>Space: $O(1)$</li>
          </ul>
          <h4>Explanation</h4>
          <p>Synchronizes city names with distances while heapifying and swapping to output farthest‚Äëto‚Äëclosest ordering.</p>
          <div class="link-placeholder"><a href="heap_sort.cpp" id="link-heapsort">View Heap Sort code</a></div>
        </div>
      </section>

      <!-- Conclusion -->
      <div class="conclusion">
        <h2> Conclusion</h2>
        <p>The Smart City design for Sagarika Nagar demonstrates how diverse Data Structures and Algorithms can solve real-world urban challenges efficiently. By applying shortest-path algorithms, balanced trees, hashing, and advanced pattern-matching techniques, the city can optimize transportation, emergency response, utilities, parking, and digital citizen services. Each algorithm enhances decision-making speed, reduces resource wastage, and improves overall city management. This project shows that DAA is not just theoretical-it directly supports smarter, safer, and more efficient city planning.</p>
      </div>
      
      <div style="text-align: center; margin-top: 3rem;">
        <a href="DAA website 2 1.html" style="display: inline-block; padding: 1rem 2rem; background: #667eea; color: white; border-radius: 8px; text-decoration: none; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);">‚Üê Back to Main Portfolio</a>
      </div>
    </div>
  </body>
</html>





